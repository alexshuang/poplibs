// Copyright (c) 2020 Graphcore Ltd. All rights reserved.
#include <poplibs_test/CTCInference.hpp>

#include <boost/optional.hpp>

#include <algorithm>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <random>
#include <string>
#include <tuple>

using namespace poplibs_support;

namespace poplibs_test {
namespace ctc {

// Probabilities representing the final symbol of a beam
template <typename FPType> struct BeamProbability {
  FPType p;  // non blank
  FPType pb; // blank
};

template <typename FPType> struct Candidate {
  unsigned beam;   // Parent output sequence
  unsigned addend; // Symbol to append onto beam

  FPType p;  // beam and non blank
  FPType pb; // beam and blank
};

struct BeamHistory {
  // symbols array contains the output sequences for each beam, with an entry at
  // every timestep (so potentially "oversampled"). Traversing through this
  // array builds up the actual output sequence by either:
  //  - voidSymbol -> no change in output sequence
  //  - otherwise -> appended to output sequence
  // so traversing `a` -> `a` in the table represents the output sequence `aa`,
  // not `a`!
  boost::multi_array<unsigned, 2> symbols;
  boost::multi_array<boost::optional<unsigned>, 2>
      parents; // If unset, no parent for convenience

  // This represents the position which is one beyond the end of the assigned
  // beams (assessed with candidates)
  unsigned nextIndexToAssign = 0;

  BeamHistory(unsigned beamwidth, unsigned t)
      : symbols(boost::extents[beamwidth][t]),
        parents(boost::extents[beamwidth][t]) {}

  std::vector<unsigned> getOutputSequence(unsigned beamIndex) const {
    std::vector<unsigned> reversedSequence;

    for (int i = nextIndexToAssign - 1; i >= 0; i--) {
      if (symbols[beamIndex][i] != voidSymbol) {
        reversedSequence.push_back(symbols[beamIndex][i]);
      }
      if (parents[beamIndex][i]) {
        beamIndex = *parents[beamIndex][i];
      }
    }
    // We traversed backwards
    std::reverse(reversedSequence.begin(), reversedSequence.end());
    return reversedSequence;
  }

  template <typename FPType>
  std::vector<unsigned>
  getOutputSequence(const Candidate<FPType> &candidate) const {
    auto output = getOutputSequence(candidate.beam);
    if (candidate.addend != voidSymbol) {
      output.push_back(candidate.addend);
    }
    return output;
  }

  // Find the last symbol in the beam output sequence
  unsigned getLastOutput(unsigned beamIndex) const {
    auto o = getOutputSequence(beamIndex);
    if (o.empty()) {
      return voidSymbol;
    } else {
      return o.back();
    }
  }

  void assignParent(unsigned beamIndex, unsigned parentBeamIndex) {
    parents[beamIndex][nextIndexToAssign] = parentBeamIndex;
  }

  void assignSymbol(unsigned beamIndex, unsigned addend) {
    symbols[beamIndex][nextIndexToAssign] = addend;
  }

  void incrementIndex() { nextIndexToAssign++; }
};

template <typename FPType>
void print(const std::vector<Candidate<FPType>> &candidates,
           const BeamHistory &beamHistory) {
  for (const auto &candidate : candidates) {
    std::cout << "(Beam=" << candidate.beam;
    std::cout << ", addend: ";
    if (candidate.addend == voidSymbol) {
      std::cout << " ";
    } else {
      std::cout << candidate.addend;
    }
    std::cout << std::fixed << std::setprecision(4) << " [p: " << candidate.p
              << ", pb: " << candidate.pb << "]) ";
    print(beamHistory.getOutputSequence(candidate));
  }
}

void print(const BeamHistory &beamHistory) {
  for (size_t c = 0; c < beamHistory.symbols.size(); c++) {
    for (size_t t = 0; t < beamHistory.nextIndexToAssign; t++) {
      const std::string parent =
          beamHistory.parents[c][t] ? std::to_string(*beamHistory.parents[c][t])
                                    : std::string{" "};
      const std::string symbol = beamHistory.symbols[c][t] != voidSymbol
                                     ? std::to_string(beamHistory.symbols[c][t])
                                     : std::string{" "};
      std::cout << "(" << parent << ", " << symbol << ") ";
    }
    std::cout << std::endl;
  }
}

template <typename FPType>
std::vector<Candidate<FPType>> generateCandidates(
    const boost::multi_array<FPType, 2> &input, unsigned t,
    const std::vector<BeamProbability<FPType>> &beamProbabilities,
    const BeamHistory &beamHistory, unsigned blankSymbol, bool useLog) {
  // Each beam can be considered to end with both a non-blank and blank
  // symbol, which is represented by `BeamProbability`. Candidates are
  // notionally generated by appending symbols (all non-blank and the blank
  // symbol) at the next timestep to the beams (considering also that the beam
  // ends in both a non-blank and blank symbol).
  // However we need to combine beams with the same output. We can do some of
  // this immediately by considering copying (same output as the parent beam)
  // and extending (different output to the parent beam) beams. Examples of the
  // combining cases are given inline below for a beam output sequence of "a".

  std::vector<Candidate<FPType>> candidates;
  const auto numClassesIncBlank = input.size();
  const FPType zero = useLog ? log::min : 0;

  unsigned beamIdx = 0;
  for (const auto &beam : beamProbabilities) {
    auto prevSymbol = beamHistory.getLastOutput(beamIdx);

    // Copy beams ---
    // Where we maintain the same beam output sequence

    // By appending a blank to beam ending in a blank
    // e.g. beam: "a-", addend: "-" -> output: "a"
    const auto blankProb = input[blankSymbol][t];
    const auto prevBlankProb =
        useLog ? log::mul(beam.pb, blankProb) : beam.pb * blankProb;
    // By appending a blank to a beam ending in a non blank
    // e.g. beam: "a", addend: "-" -> output: "a"
    const auto prevNonBlankProb =
        useLog ? log::mul(beam.p, blankProb) : beam.p * blankProb;
    const auto prob = useLog ? log::add(prevBlankProb, prevNonBlankProb)
                             : prevBlankProb + prevNonBlankProb;
    candidates.push_back({beamIdx, voidSymbol, zero, prob});

    // By appending the same symbol as at the end of the beam
    // e.g. beam: "a", addend: "a" -> output: "a"
    if (prevSymbol != voidSymbol) {
      const auto addendProb = input[prevSymbol][t];
      const auto nonBlankProb =
          useLog ? log::mul(beam.p, addendProb) : beam.p * addendProb;
      // Note: We don't need to create a new candidate as this will have the
      // same output sequence as the previous copy beam candidate which appended
      // a blank
      candidates.back().p = nonBlankProb;
    }

    // Extend beams ---
    // Where we extend a beam by adding a symbol
    for (unsigned s = 0; s < numClassesIncBlank; s++) {
      if (s == blankSymbol) {
        continue;
      }
      // Extending a beam ending in a blank with a non-blank symbol
      // e.g. beam: "a-", addend: "a" -> output: "aa" (extended by the
      // same symbol)
      // or beam: "a-", addend: "b" -> output: "ab" (extended by a
      // different symbol)
      // The second of these cases is referenced below
      const auto addendProb = input[s][t];
      const auto blankProb =
          useLog ? log::mul(beam.pb, addendProb) : beam.pb * addendProb;
      candidates.push_back({beamIdx, s, blankProb, zero});

      // Extending a beam ending in a non-blank with a different
      // non-blank symbol
      // e.g. beam: "a", addend: "b" -> output: "ab"
      if (prevSymbol != s) {
        const auto nonBlankProb =
            useLog ? log::mul(beam.p, addendProb) : beam.p * addendProb;
        // Note: We don't need to create a new candidate as this will have the
        // same output sequence as the previous extend beam candidate
        // "(extended by a different symbol)". Here we append the new
        // symbol which is different to the symbol the beam ended with to the
        // non-blank beam.
        candidates.back().p = useLog
                                  ? log::add(candidates.back().p, nonBlankProb)
                                  : candidates.back().p + nonBlankProb;
      }
    }
    beamIdx++;
  }

  return candidates;
}

template <typename FPType>
std::vector<Candidate<FPType>>
mergeEquivalentCandidates(const std::vector<Candidate<FPType>> &candidates,
                          const BeamHistory &beamHistory, bool useLog) {
  std::vector<Candidate<FPType>> mergedCandidates = candidates;

  for (size_t j = 0; j < mergedCandidates.size(); j++) {
    for (size_t i = j + 1; i < mergedCandidates.size(); i++) {
      auto &lhs = mergedCandidates[j];
      const auto &rhs = mergedCandidates[i];
      // The only way for candidates to become mergeable is if one is a copy
      // beam (same output sequence from parent beam), and the other extension
      // (of a different beam). This is from; if both candidates are copy, the
      // output sequence of parent beams will be unchanged so not made
      // equivalent. Or alternatively, both are extension, they will need to be
      // from the same output sequence which means they cannot be extending by
      // the same symbol and so not equivalent.
      if (lhs.beam == rhs.beam) {
        continue;
      }

      // TODO improve merge check efficiency
      if (beamHistory.getOutputSequence(lhs) ==
          beamHistory.getOutputSequence(rhs)) {
        lhs.p = useLog ? log::add(lhs.p, rhs.p) : lhs.p + rhs.p;
        lhs.pb = useLog ? log::add(lhs.pb, rhs.pb) : lhs.pb + rhs.pb;

        // It doesn't matter which we remove as they result in the same output
        // sequence since they are equivalent
        mergedCandidates.erase(mergedCandidates.begin() + i);
        i--;
      }
    }
  }

  return mergedCandidates;
}

template <typename FPType>
std::vector<Candidate<FPType>>
sortCandidates(const std::vector<Candidate<FPType>> &candidates, bool useLog) {
  std::vector<Candidate<FPType>> out = candidates;
  std::sort(out.begin(), out.end(),
            [&](const Candidate<FPType> &lhs, const Candidate<FPType> &rhs) {
              auto lhsSum = useLog ? log::add(lhs.p, lhs.pb) : lhs.p + lhs.pb;
              auto rhsSum = useLog ? log::add(rhs.p, rhs.pb) : rhs.p + rhs.pb;
              return lhsSum > rhsSum;
            });
  return out;
}

template <typename FPType>
std::vector<Candidate<FPType>>
pruneCandidates(const std::vector<Candidate<FPType>> &candidates, size_t max,
                bool useLog) {
  std::vector<Candidate<FPType>> out = candidates;
  out.resize(max);
  for (unsigned i = candidates.size(); i < out.size(); i++) {
    out[i].p = useLog ? log::min : 0;
    out[i].pb = useLog ? log::min : 0;
  }
  return out;
}

template <typename FPType>
void applyCandidates(BeamHistory &beamHistory,
                     std::vector<BeamProbability<FPType>> &beamProbabilities,
                     const std::vector<Candidate<FPType>> &candidates,
                     bool useLog) {
  // Ideally we would maintain consistency for easier debugging (stop changing
  // beam parents where possible), but for now let's reorder beams in terms of
  // probability (implicit assumption candidates is sorted here)
  auto idx = 0;
  for (auto candidate : candidates) {
    beamHistory.assignParent(idx, candidate.beam);
    beamHistory.assignSymbol(idx, candidate.addend);
    beamProbabilities.at(idx).p = candidate.p;
    beamProbabilities.at(idx).pb = candidate.pb;
    idx++;
  }
  beamHistory.incrementIndex();
}

template <typename FPType>
std::tuple<FPType, std::vector<unsigned>>
infer(const boost::multi_array<FPType, 2> &input, unsigned blankSymbol,
      unsigned beamwidth, bool useLog, bool verbose) {

  const FPType maxProb = useLog ? 0 : 1;
  const FPType minProb = useLog ? log::min : 0;
  std::vector<BeamProbability<FPType>> beamProbabilities{};
  beamProbabilities.push_back({maxProb, minProb}); // Only one origin to begin
  for (size_t i = 1; i < beamwidth; i++) {
    beamProbabilities.push_back({minProb, minProb}); // Ignore other beams
  }

  BeamHistory beamHistory{beamwidth, static_cast<unsigned>(input[0].size())};

  for (size_t t = 0; t < input[0].size(); t++) {
    auto candidates = generateCandidates(input, t, beamProbabilities,
                                         beamHistory, blankSymbol, useLog);

    if (verbose) {
      std::cout << "Candidates:" << std::endl;
      print(candidates, beamHistory);
      std::cout << std::endl;
    }
    candidates = mergeEquivalentCandidates(candidates, beamHistory, useLog);

    if (verbose) {
      std::cout << "Merged:" << std::endl;
      print(candidates, beamHistory);
      std::cout << std::endl;
    }

    candidates = sortCandidates(candidates, useLog);

    if (verbose) {
      std::cout << "Sorted:" << std::endl;
      print(candidates, beamHistory);
      std::cout << std::endl;
    }

    const auto selectedCandidates =
        pruneCandidates(candidates, beamwidth, useLog);

    if (verbose) {
      std::cout << "Pruned:" << std::endl;
      print(selectedCandidates, beamHistory);
      std::cout << std::endl;
    }

    applyCandidates(beamHistory, beamProbabilities, selectedCandidates, useLog);

    if (verbose) {
      std::cout << "==============" << std::endl;
      std::cout << std::endl;

      std::cout << "Beam history: (Parent Beam reference, current symbol)"
                << std::endl;
      print(beamHistory);
      std::cout << std::endl;

      std::cout << "Current beam outputs:" << std::endl;
      for (size_t i = 0; i < beamwidth; i++) {
        std::cout << "[p: " << beamProbabilities[i].p
                  << ", pb: " << beamProbabilities[i].pb << ", p + pb: "
                  << (useLog ? log::add(beamProbabilities[i].p,
                                        beamProbabilities[i].pb)
                             : beamProbabilities[i].p + beamProbabilities[i].pb)
                  << "] ";
        print(beamHistory.getOutputSequence(i));
      }
      std::cout << std::endl;
      std::cout << "==============" << std::endl;
      std::cout << std::endl;
    }
  }

  // We don't need to sort since beam probabilities already kept sorted
  // (implicit)
  const auto output = beamHistory.getOutputSequence(0);

  auto sum =
      useLog ? log::add(beamProbabilities.at(0).p, beamProbabilities.at(0).pb)
             : beamProbabilities.at(0).p + beamProbabilities.at(0).pb;
  if (verbose) {
    std::cout << "Output:" << std::endl;
  }
  print(output);
  if (useLog) {
    std::cout << "P = " << std::exp(sum) << std::endl;
    std::cout << "Log(P) = " << sum << std::endl;

  } else {
    std::cout << "P = " << sum << std::endl;
    std::cout << "Log(P) = " << std::log(sum) << std::endl;
    sum = std::log(sum);
  }
  return {sum, output};
}

template std::tuple<double, std::vector<unsigned>>
infer(const boost::multi_array<double, 2> &input, unsigned blankSymbol,
      unsigned beamwidth, bool useLog, bool verbose);

template std::tuple<float, std::vector<unsigned>>
infer(const boost::multi_array<float, 2> &input, unsigned blankSymbol,
      unsigned beamwidth, bool useLog, bool verbose);

/// ====================================================================
/// ====================================================================
/// ====================================================================
/// ====================================================================
/// ====================================================================

// Exhaustive path inference functions.  Coded to look simple and be divided
// into lots of individually verifiable steps and help with debug.

// For inference, build an array of the indices of all possible input paths
// given no constraint whatsoever.  This can blow up huge so be careful!
boost::multi_array<unsigned, 2> findAllInputPaths(unsigned timeSteps,
                                                  unsigned sequenceLength) {

  auto paths = std::pow(sequenceLength, timeSteps);
  boost::multi_array<unsigned, 2> result(boost::extents[paths][timeSteps]);
  unsigned beamSize = sequenceLength;
  for (unsigned t = 0; t < timeSteps; t++) {
    for (unsigned s = 0; s < beamSize; s++) {
      for (unsigned p = 0; p < paths / beamSize; p++)
        result[s * (paths / beamSize) + p][t] = s % sequenceLength;
    }
    beamSize *= sequenceLength;
  }
  return result;
}

// Just follow each inputPath we are given, and multiply probabilities
template <typename FPType>
boost::multi_array<FPType, 1>
findAllInputPathProbabilities(const boost::multi_array<FPType, 2> &sequence,
                              const boost::multi_array<unsigned, 2> &inputPaths,
                              bool isLog) {

  auto paths = inputPaths.shape()[0];
  auto timeSteps = inputPaths.shape()[1];

  boost::multi_array<FPType, 1> result(boost::extents[paths]);
  std::fill(result.data(), result.data() + result.num_elements(),
            isLog ? 0 : 1);

  for (unsigned t = 0; t < timeSteps; t++) {
    for (unsigned p = 0; p < paths; p++) {
      if (isLog) {
        result[p] = log::mul(result[p], sequence[inputPaths[p][t]][t]);
      } else {
        result[p] *= sequence[inputPaths[p][t]][t];
      }
    }
  }
  return result;
}

// Convert input paths into output paths (padded with -1)
boost::multi_array<unsigned, 2>
inputToOutputPath(const boost::multi_array<unsigned, 2> &inputPath,
                  unsigned blankSymbol) {
  auto paths = inputPath.shape()[0];
  auto timeSteps = inputPath.shape()[1];
  boost::multi_array<unsigned, 2> result(boost::extents[paths][timeSteps]);
  // Fill with void symbol to represent null
  std::fill(result.data(), result.data() + result.num_elements(), voidSymbol);

  for (unsigned p = 0; p < paths; p++) {
    auto lastOne = blankSymbol;
    unsigned length = 0;
    for (unsigned t = 0; t < timeSteps; t++) {

      if (lastOne != inputPath[p][t] && inputPath[p][t] != blankSymbol) {
        // Insert a new symbol
        result[p][length] = inputPath[p][t];
        length++;
      }
      lastOne = inputPath[p][t];
    }
  }
  return result;
}

// Merge identical output paths by generating a reference to the first instance
// of a path, and summing the probabilities of all identical paths.
template <typename FPType>
std::tuple<std::vector<unsigned>, std::vector<FPType>,
           std::vector<std::vector<unsigned>>>
mergePaths(boost::multi_array<unsigned, 2> &outPaths,
           boost::multi_array<FPType, 1> &probabilities, bool isLog) {
  std::vector<unsigned> pathRefs;
  std::vector<FPType> pathProbs;
  std::vector<std::vector<unsigned>> instances;

  for (unsigned outPath = 0; outPath < outPaths.size(); outPath++) {
    unsigned matchIndex = 0;
    bool matchFound = false;
    for (unsigned ref = 0; ref < pathRefs.size(); ref++) {
      if (outPaths[outPath] == outPaths[pathRefs[ref]]) {
        matchIndex = ref;
        matchFound = true;
        break;
      }
    }
    if (matchFound) {
      instances[matchIndex].push_back(outPath);
      if (isLog) {
        pathProbs[matchIndex] =
            log::add(pathProbs[matchIndex], probabilities[outPath]);
      } else {
        pathProbs[matchIndex] += probabilities[outPath];
      }
    } else {
      pathRefs.push_back(outPath);
      pathProbs.push_back(probabilities[outPath]);
      instances.resize(instances.size() + 1);
      instances.back().push_back(outPath);
    }
  }
  return {pathRefs, pathProbs, instances};
}

template std::tuple<std::vector<unsigned>, std::vector<double>,
                    std::vector<std::vector<unsigned>>>
mergePaths(boost::multi_array<unsigned, 2> &outPaths,
           boost::multi_array<double, 1> &probabilities, bool isLog);

template std::tuple<std::vector<unsigned>, std::vector<float>,
                    std::vector<std::vector<unsigned>>>
mergePaths(boost::multi_array<unsigned, 2> &outPaths,
           boost::multi_array<float, 1> &probabilities, bool isLog);

template boost::multi_array<double, 1>
findAllInputPathProbabilities(const boost::multi_array<double, 2> &sequence,
                              const boost::multi_array<unsigned, 2> &inputPaths,
                              bool isLog);

template boost::multi_array<float, 1>
findAllInputPathProbabilities(const boost::multi_array<float, 2> &sequence,
                              const boost::multi_array<unsigned, 2> &inputPaths,
                              bool isLog);

} // namespace ctc
} // namespace poplibs_test
